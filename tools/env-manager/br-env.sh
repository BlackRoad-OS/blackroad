#!/usr/bin/env zsh

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
NC='\033[0m'

DB_FILE="$HOME/.blackroad/env-manager.db"

init_db() {
    mkdir -p "$(dirname "$DB_FILE")"
    sqlite3 "$DB_FILE" <<EOF
CREATE TABLE IF NOT EXISTS env_files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT UNIQUE,
    project_name TEXT,
    created_at INTEGER,
    last_modified INTEGER
);

CREATE TABLE IF NOT EXISTS variables (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    key TEXT,
    value TEXT,
    env_file_path TEXT,
    is_secret INTEGER DEFAULT 0,
    created_at INTEGER
);

CREATE TABLE IF NOT EXISTS templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE,
    content TEXT,
    created_at INTEGER
);
EOF
}

cmd_init() {
    init_db
    local file="${1:-.env}"
    
    if [[ -f "$file" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  File $file already exists${NC}"
        return
    fi
    
    cat > "$file" << 'ENVTEMPLATE'
# Environment Configuration
# Generated by BlackRoad CLI

# Application
APP_NAME=my-app
APP_ENV=development
APP_PORT=3000

# Database
DATABASE_URL=

# API Keys
API_KEY=
API_SECRET=

# Feature Flags
ENABLE_FEATURE_X=false
ENVTEMPLATE
    
    local abs_path=$(realpath "$file")
    sqlite3 "$DB_FILE" "INSERT OR REPLACE INTO env_files (path, project_name, created_at, last_modified) VALUES ('$abs_path', '$(basename $(pwd))', $(date +%s), $(date +%s));"
    
    echo -e "${GREEN}‚úì Created $file${NC}"
    echo -e "${CYAN}üí° Edit with: br env edit $file${NC}"
}

cmd_list() {
    init_db
    local file="${1:-.env}"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}‚ùå File $file not found${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}üìã Environment Variables in $file:${NC}\n"
    
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        
        # Mask potential secrets
        if [[ "$key" =~ (SECRET|PASSWORD|TOKEN|KEY|PRIVATE) ]]; then
            echo -e "${YELLOW}üîí${NC} $key=${BLUE}****${NC}"
        else
            echo -e "${GREEN}‚óè${NC} $key=${BLUE}$value${NC}"
        fi
    done < "$file"
}

cmd_get() {
    local file="${1:-.env}"
    local key="$2"
    
    if [[ -z "$key" ]]; then
        echo -e "${RED}‚ùå Specify variable name${NC}"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}‚ùå File $file not found${NC}"
        exit 1
    fi
    
    local value=$(grep "^${key}=" "$file" | cut -d'=' -f2-)
    
    if [[ -z "$value" ]]; then
        echo -e "${RED}‚ùå Variable $key not found${NC}"
        exit 1
    fi
    
    echo "$value"
}

cmd_set() {
    init_db
    local file="${1:-.env}"
    local key="$2"
    local value="$3"
    
    if [[ -z "$key" || -z "$value" ]]; then
        echo -e "${RED}‚ùå Usage: br env set <file> <key> <value>${NC}"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  File $file not found, creating...${NC}"
        touch "$file"
    fi
    
    # Check if key exists
    if grep -q "^${key}=" "$file"; then
        # Update existing
        sed -i.bak "s/^${key}=.*/${key}=${value}/" "$file" && rm "${file}.bak"
        echo -e "${GREEN}‚úì Updated $key${NC}"
    else
        # Add new
        echo "${key}=${value}" >> "$file"
        echo -e "${GREEN}‚úì Added $key${NC}"
    fi
    
    local abs_path=$(realpath "$file")
    local is_secret=0
    [[ "$key" =~ (SECRET|PASSWORD|TOKEN|KEY|PRIVATE) ]] && is_secret=1
    sqlite3 "$DB_FILE" "INSERT INTO variables (key, value, env_file_path, is_secret, created_at) VALUES ('$key', '$value', '$abs_path', $is_secret, $(date +%s));"
}

cmd_unset() {
    local file="${1:-.env}"
    local key="$2"
    
    if [[ -z "$key" ]]; then
        echo -e "${RED}‚ùå Specify variable name${NC}"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}‚ùå File $file not found${NC}"
        exit 1
    fi
    
    sed -i.bak "/^${key}=/d" "$file" && rm "${file}.bak"
    echo -e "${GREEN}‚úì Removed $key${NC}"
}

cmd_copy() {
    local source="${1:-.env}"
    local dest="$2"
    
    if [[ -z "$dest" ]]; then
        echo -e "${RED}‚ùå Usage: br env copy <source> <dest>${NC}"
        exit 1
    fi
    
    if [[ ! -f "$source" ]]; then
        echo -e "${RED}‚ùå Source file $source not found${NC}"
        exit 1
    fi
    
    cp "$source" "$dest"
    echo -e "${GREEN}‚úì Copied $source ‚Üí $dest${NC}"
    
    # Optionally clear secrets
    read "clear?Clear secrets in copy? (y/N): "
    if [[ "$clear" =~ ^[Yy]$ ]]; then
        sed -i.bak -E 's/(SECRET|PASSWORD|TOKEN|KEY|PRIVATE)=.*$/\1=/' "$dest" && rm "${dest}.bak"
        echo -e "${GREEN}‚úì Cleared secrets in $dest${NC}"
    fi
}

cmd_diff() {
    local file1="${1:-.env}"
    local file2="${2:-.env.example}"
    
    if [[ ! -f "$file1" || ! -f "$file2" ]]; then
        echo -e "${RED}‚ùå Both files must exist${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}üîç Differences between $file1 and $file2:${NC}\n"
    
    # Keys in file1 but not in file2
    echo -e "${BLUE}Only in $file1:${NC}"
    while IFS='=' read -r key _; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        grep -q "^${key}=" "$file2" || echo "  + $key"
    done < "$file1"
    
    echo ""
    
    # Keys in file2 but not in file1
    echo -e "${YELLOW}Only in $file2:${NC}"
    while IFS='=' read -r key _; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        grep -q "^${key}=" "$file1" || echo "  - $key"
    done < "$file2"
}

cmd_validate() {
    local file="${1:-.env}"
    local template="${2:-.env.example}"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}‚ùå File $file not found${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}‚úÖ Validating $file...${NC}\n"
    
    local errors=0
    
    # Check for empty values
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        if [[ -z "$value" ]]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Empty value: $key${NC}"
            errors=$((errors + 1))
        fi
    done < "$file"
    
    # Check against template if exists
    if [[ -f "$template" ]]; then
        while IFS='=' read -r key _; do
            [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
            if ! grep -q "^${key}=" "$file"; then
                echo -e "${RED}‚ùå Missing required: $key${NC}"
                errors=$((errors + 1))
            fi
        done < "$template"
    fi
    
    if [[ $errors -eq 0 ]]; then
        echo -e "${GREEN}‚úì All checks passed${NC}"
    else
        echo -e "\n${RED}Found $errors issue(s)${NC}"
        exit 1
    fi
}

cmd_export() {
    local file="${1:-.env}"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}‚ùå File $file not found${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}üì§ Exporting variables from $file...${NC}\n"
    
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        export "$key"="$value"
        echo -e "${GREEN}‚úì${NC} Exported $key"
    done < "$file"
}

cmd_help() {
    cat << 'EOF'
üîê Environment Manager

USAGE:
  br env <command> [options]

FILE COMMANDS:
  init [file]              Create new .env file
  list [file]              List all variables
  edit [file]              Open file in editor

VARIABLE COMMANDS:
  get <file> <key>         Get variable value
  set <file> <key> <val>   Set variable
  unset <file> <key>       Remove variable
  export [file]            Export to shell

FILE OPERATIONS:
  copy <source> <dest>     Copy env file (optionally clear secrets)
  diff <file1> <file2>     Show differences
  validate [file] [tmpl]   Validate against template

EXAMPLES:
  br env init
  br env list
  br env set .env API_KEY abc123
  br env get .env API_KEY
  br env copy .env .env.local
  br env diff .env .env.example
  br env validate .env
  br env export .env

NOTES:
  - Secrets (PASSWORD, TOKEN, KEY, SECRET) are masked in output
  - Default file is .env in current directory
  - Use quotes for values with spaces

EOF
}

# Main dispatch
init_db

case "${1:-help}" in
    init) cmd_init "${@:2}" ;;
    list|ls) cmd_list "${@:2}" ;;
    edit)
        file="${2:-.env}"
        ${EDITOR:-vim} "$file"
        ;;
    get) cmd_get "${@:2}" ;;
    set) cmd_set "${@:2}" ;;
    unset|rm) cmd_unset "${@:2}" ;;
    copy|cp) cmd_copy "${@:2}" ;;
    diff) cmd_diff "${@:2}" ;;
    validate|check) cmd_validate "${@:2}" ;;
    export) cmd_export "${@:2}" ;;
    help|--help|-h) cmd_help ;;
    *)
        echo -e "${RED}‚ùå Unknown command: $1${NC}"
        cmd_help
        exit 1
        ;;
esac
