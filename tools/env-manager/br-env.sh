#!/usr/bin/env zsh

# Colors
AMBER='\033[38;5;214m'; PINK='\033[38;5;205m'; VIOLET='\033[38;5;135m'; BBLUE='\033[38;5;69m'
GREEN='\033[0;32m'; RED='\033[0;31m'; BOLD='\033[1m'; DIM='\033[2m'; NC='\033[0m'
CYAN="$AMBER"; YELLOW="$PINK"; BLUE="$BBLUE"; MAGENTA="$VIOLET"; PURPLE="$VIOLET"

DB_FILE="$HOME/.blackroad/env-manager.db"

init_db() {
    mkdir -p "$(dirname "$DB_FILE")"
    sqlite3 "$DB_FILE" <<EOF
CREATE TABLE IF NOT EXISTS env_files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT UNIQUE,
    project_name TEXT,
    created_at INTEGER,
    last_modified INTEGER
);

CREATE TABLE IF NOT EXISTS variables (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    key TEXT,
    value TEXT,
    env_file_path TEXT,
    is_secret INTEGER DEFAULT 0,
    created_at INTEGER
);

CREATE TABLE IF NOT EXISTS templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE,
    content TEXT,
    created_at INTEGER
);
EOF
}

cmd_init() {
    init_db
    local file="${1:-.env}"
    
    if [[ -f "$file" ]]; then
        echo -e "${YELLOW}âš ï¸  File $file already exists${NC}"
        return
    fi
    
    cat > "$file" << 'ENVTEMPLATE'
# Environment Configuration
# Generated by BlackRoad CLI

# Application
APP_NAME=my-app
APP_ENV=development
APP_PORT=3000

# Database
DATABASE_URL=

# API Keys
API_KEY=
API_SECRET=

# Feature Flags
ENABLE_FEATURE_X=false
ENVTEMPLATE
    
    local abs_path=$(realpath "$file")
    sqlite3 "$DB_FILE" "INSERT OR REPLACE INTO env_files (path, project_name, created_at, last_modified) VALUES ('$abs_path', '$(basename $(pwd))', $(date +%s), $(date +%s));"
    
    echo -e "${GREEN}âœ“ Created $file${NC}"
    echo -e "${CYAN}ğŸ’¡ Edit with: br env edit $file${NC}"
}

cmd_list() {
    init_db
    local file="${1:-.env}"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}âŒ File $file not found${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}ğŸ“‹ Environment Variables in $file:${NC}\n"
    
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        
        # Mask potential secrets
        if [[ "$key" =~ (SECRET|PASSWORD|TOKEN|KEY|PRIVATE) ]]; then
            echo -e "${YELLOW}ğŸ”’${NC} $key=${BLUE}****${NC}"
        else
            echo -e "${GREEN}â—${NC} $key=${BLUE}$value${NC}"
        fi
    done < "$file"
}

cmd_get() {
    local file="${1:-.env}"
    local key="$2"
    
    if [[ -z "$key" ]]; then
        echo -e "${RED}âŒ Specify variable name${NC}"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}âŒ File $file not found${NC}"
        exit 1
    fi
    
    local value=$(grep "^${key}=" "$file" | cut -d'=' -f2-)
    
    if [[ -z "$value" ]]; then
        echo -e "${RED}âŒ Variable $key not found${NC}"
        exit 1
    fi
    
    echo "$value"
}

cmd_set() {
    init_db
    local file="${1:-.env}"
    local key="$2"
    local value="$3"
    
    if [[ -z "$key" || -z "$value" ]]; then
        echo -e "${RED}âŒ Usage: br env set <file> <key> <value>${NC}"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo -e "${YELLOW}âš ï¸  File $file not found, creating...${NC}"
        touch "$file"
    fi
    
    # Check if key exists
    if grep -q "^${key}=" "$file"; then
        # Update existing
        sed -i.bak "s/^${key}=.*/${key}=${value}/" "$file" && rm "${file}.bak"
        echo -e "${GREEN}âœ“ Updated $key${NC}"
    else
        # Add new
        echo "${key}=${value}" >> "$file"
        echo -e "${GREEN}âœ“ Added $key${NC}"
    fi
    
    local abs_path=$(realpath "$file")
    local is_secret=0
    [[ "$key" =~ (SECRET|PASSWORD|TOKEN|KEY|PRIVATE) ]] && is_secret=1
    sqlite3 "$DB_FILE" "INSERT INTO variables (key, value, env_file_path, is_secret, created_at) VALUES ('$key', '$value', '$abs_path', $is_secret, $(date +%s));"
}

cmd_unset() {
    local file="${1:-.env}"
    local key="$2"
    
    if [[ -z "$key" ]]; then
        echo -e "${RED}âŒ Specify variable name${NC}"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}âŒ File $file not found${NC}"
        exit 1
    fi
    
    sed -i.bak "/^${key}=/d" "$file" && rm "${file}.bak"
    echo -e "${GREEN}âœ“ Removed $key${NC}"
}

cmd_copy() {
    local source="${1:-.env}"
    local dest="$2"
    
    if [[ -z "$dest" ]]; then
        echo -e "${RED}âŒ Usage: br env copy <source> <dest>${NC}"
        exit 1
    fi
    
    if [[ ! -f "$source" ]]; then
        echo -e "${RED}âŒ Source file $source not found${NC}"
        exit 1
    fi
    
    cp "$source" "$dest"
    echo -e "${GREEN}âœ“ Copied $source â†’ $dest${NC}"
    
    # Optionally clear secrets
    read "clear?Clear secrets in copy? (y/N): "
    if [[ "$clear" =~ ^[Yy]$ ]]; then
        sed -i.bak -E 's/(SECRET|PASSWORD|TOKEN|KEY|PRIVATE)=.*$/\1=/' "$dest" && rm "${dest}.bak"
        echo -e "${GREEN}âœ“ Cleared secrets in $dest${NC}"
    fi
}

cmd_diff() {
    local file1="${1:-.env}"
    local file2="${2:-.env.example}"
    
    if [[ ! -f "$file1" || ! -f "$file2" ]]; then
        echo -e "${RED}âŒ Both files must exist${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}ğŸ” Differences between $file1 and $file2:${NC}\n"
    
    # Keys in file1 but not in file2
    echo -e "${BLUE}Only in $file1:${NC}"
    while IFS='=' read -r key _; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        grep -q "^${key}=" "$file2" || echo "  + $key"
    done < "$file1"
    
    echo ""
    
    # Keys in file2 but not in file1
    echo -e "${YELLOW}Only in $file2:${NC}"
    while IFS='=' read -r key _; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        grep -q "^${key}=" "$file1" || echo "  - $key"
    done < "$file2"
}

cmd_validate() {
    local file="${1:-.env}"
    local template="${2:-.env.example}"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}âŒ File $file not found${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}âœ… Validating $file...${NC}\n"
    
    local errors=0
    
    # Check for empty values
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        if [[ -z "$value" ]]; then
            echo -e "${YELLOW}âš ï¸  Empty value: $key${NC}"
            errors=$((errors + 1))
        fi
    done < "$file"
    
    # Check against template if exists
    if [[ -f "$template" ]]; then
        while IFS='=' read -r key _; do
            [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
            if ! grep -q "^${key}=" "$file"; then
                echo -e "${RED}âŒ Missing required: $key${NC}"
                errors=$((errors + 1))
            fi
        done < "$template"
    fi
    
    if [[ $errors -eq 0 ]]; then
        echo -e "${GREEN}âœ“ All checks passed${NC}"
    else
        echo -e "\n${RED}Found $errors issue(s)${NC}"
        exit 1
    fi
}

cmd_export() {
    local file="${1:-.env}"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}âŒ File $file not found${NC}"
        exit 1
    fi
    
    echo -e "${CYAN}ğŸ“¤ Exporting variables from $file...${NC}\n"
    
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        export "$key"="$value"
        echo -e "${GREEN}âœ“${NC} Exported $key"
    done < "$file"
}

cmd_vault_push() {
    # br env push [file]  â€” encrypt and push .env to br vault
    local envfile="${1:-.env}"
    [[ ! -f "$envfile" ]] && { echo -e "  ${RED}âœ—${NC} file not found: $envfile"; return 1; }

    local vault_dir="${HOME}/.blackroad/vault"
    local master_key="${vault_dir}/.master.key"
    mkdir -p "$vault_dir"

    [[ ! -f "$master_key" ]] && {
        openssl rand -base64 32 > "$master_key"
        chmod 400 "$master_key"
        echo -e "  ${GREEN}âœ“${NC}  vault key created: $master_key"
    }

    local project; project=$(basename "$(pwd)")
    local dest="${vault_dir}/${project}.env.enc"
    openssl enc -aes-256-cbc -pbkdf2 -pass "file:${master_key}" -in "$envfile" -out "$dest" 2>/dev/null
    local count; count=$(grep -c '=' "$envfile" 2>/dev/null || echo 0)

    echo ""
    echo -e "  ${AMBER}${BOLD}â—† BR ENV${NC}  ${DIM}vault push${NC}"
    echo -e "  ${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "  ${GREEN}âœ“${NC}  encrypted $count vars â†’ ${BOLD}${dest}${NC}"
    echo -e "  ${DIM}â†’  br env pull to restore${NC}"
    echo ""
}

cmd_vault_pull() {
    # br env pull [project] [dest]  â€” decrypt from vault to .env
    local project="${1:-$(basename "$(pwd)")}"
    local dest="${2:-.env}"

    local vault_dir="${HOME}/.blackroad/vault"
    local master_key="${vault_dir}/.master.key"
    local src="${vault_dir}/${project}.env.enc"

    [[ ! -f "$src" ]] && { echo -e "  ${RED}âœ—${NC} no vault entry for: $project  (run: br env push)"; return 1; }
    [[ ! -f "$master_key" ]] && { echo -e "  ${RED}âœ—${NC} vault key missing: $master_key"; return 1; }

    openssl enc -d -aes-256-cbc -pbkdf2 -pass "file:${master_key}" -in "$src" -out "$dest" 2>/dev/null
    local count; count=$(grep -c '=' "$dest" 2>/dev/null || echo 0)

    echo ""
    echo -e "  ${AMBER}${BOLD}â—† BR ENV${NC}  ${DIM}vault pull${NC}"
    echo -e "  ${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "  ${GREEN}âœ“${NC}  decrypted $count vars â†’ ${BOLD}${dest}${NC}"
    echo ""
}

cmd_vault_diff() {
    # br env diff [file] â€” compare .env vs vault snapshot
    local envfile="${1:-.env}"
    local project; project=$(basename "$(pwd)")

    local vault_dir="${HOME}/.blackroad/vault"
    local master_key="${vault_dir}/.master.key"
    local src="${vault_dir}/${project}.env.enc"

    [[ ! -f "$envfile" ]] && { echo -e "  ${RED}âœ—${NC} file not found: $envfile"; return 1; }
    [[ ! -f "$src" ]] && { echo -e "  ${RED}âœ—${NC} no vault entry for: $project  (run: br env push)"; return 1; }

    local tmp; tmp=$(mktemp)
    openssl enc -d -aes-256-cbc -pbkdf2 -pass "file:${master_key}" -in "$src" -out "$tmp" 2>/dev/null

    echo ""
    echo -e "  ${AMBER}${BOLD}â—† BR ENV${NC}  ${DIM}diff  Â·  $envfile  vs  vault/${project}${NC}"
    echo -e "  ${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo ""

    python3 - "$envfile" "$tmp" << 'PYEOF'
import sys, re

def parse_env(path):
    d = {}
    for line in open(path):
        line = line.strip()
        if not line or line.startswith('#') or '=' not in line: continue
        k, _, v = line.partition('=')
        d[k.strip()] = v.strip()
    return d

AMBER = '\033[38;5;214m'; PINK = '\033[38;5;205m'
GREEN = '\033[0;32m';     DIM  = '\033[2m'; NC = '\033[0m'
BOLD  = '\033[1m'

local_env = parse_env(sys.argv[1])
vault_env = parse_env(sys.argv[2])

all_keys = sorted(set(local_env) | set(vault_env))
changes = 0
for k in all_keys:
    lv = local_env.get(k)
    vv = vault_env.get(k)
    secret = any(x in k.upper() for x in ['TOKEN','KEY','SECRET','PASS','PWD'])
    def mask(v): return v[:4]+'*'*(len(v)-4) if v and secret and len(v)>4 else v
    if lv is None:
        print(f"  {PINK}+{NC}  {BOLD}{k}{NC}  {PINK}(only in vault){NC}"); changes+=1
    elif vv is None:
        print(f"  {GREEN}+{NC}  {BOLD}{k}{NC}  {GREEN}(new in local){NC}"); changes+=1
    elif lv != vv:
        print(f"  {AMBER}~{NC}  {BOLD}{k}{NC}  {DIM}{mask(vv)}{NC}  â†’  {AMBER}{mask(lv)}{NC}"); changes+=1
    else:
        print(f"  {DIM}={NC}  {DIM}{k}{NC}")

print(f"\n  {DIM}{changes} change(s){NC}")
PYEOF
    rm -f "$tmp"
    echo ""
}

cmd_audit() {
    # br env audit [file]  â€” check .env vs .env.example for missing/extra keys
    local envfile="${1:-.env}"
    local example="${2:-.env.example}"

    echo ""
    echo -e "  ${AMBER}${BOLD}â—† BR ENV${NC}  ${DIM}audit  Â·  $envfile vs $example${NC}"
    echo -e "  ${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo ""

    [[ ! -f "$envfile" ]] && { echo -e "  ${RED}âœ—${NC} not found: $envfile"; return 1; }
    [[ ! -f "$example" ]] && { echo -e "  ${DIM}no $example found â€” scanning for empty values only${NC}"; echo ""; }

    python3 - "$envfile" "${example}" << 'PYEOF'
import sys, os

def parse_keys(path):
    keys = {}
    if not os.path.exists(path): return keys
    for line in open(path):
        line = line.strip()
        if not line or line.startswith('#') or '=' not in line: continue
        k, _, v = line.partition('=')
        keys[k.strip()] = v.strip()
    return keys

GREEN = '\033[0;32m'; RED = '\033[0;31m'; AMBER = '\033[38;5;214m'
PINK = '\033[38;5;205m'; DIM = '\033[2m'; BOLD = '\033[1m'; NC = '\033[0m'

local_env = parse_keys(sys.argv[1])
example   = parse_keys(sys.argv[2]) if os.path.exists(sys.argv[2]) else {}

issues = 0

# Missing keys (in example but not in local)
for k in sorted(example):
    if k not in local_env:
        print(f"  {RED}âœ—{NC}  {BOLD}{k}{NC}  {RED}MISSING{NC}"); issues+=1

# Empty values
for k, v in sorted(local_env.items()):
    if not v:
        print(f"  {AMBER}âš {NC}  {BOLD}{k}{NC}  {AMBER}EMPTY{NC}"); issues+=1

# Extra keys (in local but not in example)
if example:
    for k in sorted(local_env):
        if k not in example:
            print(f"  {DIM}+  {k}  (not in example){NC}")

if issues == 0:
    print(f"  {GREEN}âœ“{NC}  all keys present and non-empty")
else:
    print(f"\n  {RED}{issues} issue(s) found{NC}")
PYEOF
    echo ""
}

cmd_vault_list() {
    local vault_dir="${HOME}/.blackroad/vault"
    echo ""
    echo -e "  ${AMBER}${BOLD}â—† BR ENV${NC}  ${DIM}vault contents${NC}"
    echo -e "  ${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo ""
    local count=0
    for f in "${vault_dir}"/*.env.enc(N); do
        count=$((count+1))
        local name; name=$(basename "$f" .env.enc)
        local size; size=$(wc -c < "$f" 2>/dev/null | tr -d ' ')
        local ts; ts=$(python3 -c "import os; t=os.path.getmtime('$f'); import time; print(time.strftime('%Y-%m-%d %H:%M', time.localtime(t)))")
        printf "  ${AMBER}%-20s${NC}  ${DIM}%s bytes  %s${NC}\n" "$name" "$size" "$ts"
    done
    [[ $count -eq 0 ]] && echo -e "  ${DIM}vault is empty.  br env push${NC}"
    echo ""
}

cmd_help() {
    echo ""
    echo -e "  ${AMBER}${BOLD}â—† BR ENV${NC}  ${DIM}Manage env files. Encrypt them. Audit them.${NC}"
    echo -e "  ${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo ""
    echo -e "  ${BOLD}vault${NC}"
    echo -e "  ${AMBER}push${NC}   [file]                encrypt .env â†’ vault"
    echo -e "  ${AMBER}pull${NC}   [project] [dest]      decrypt from vault â†’ .env"
    echo -e "  ${AMBER}vdiff${NC}  [file]                diff local vs vault snapshot"
    echo -e "  ${AMBER}vlist${NC}                        list vault contents"
    echo -e "  ${AMBER}audit${NC}  [file] [example]      missing/empty/extra keys"
    echo ""
    echo -e "  ${BOLD}files${NC}"
    echo -e "  ${AMBER}init${NC}   [file]                create .env"
    echo -e "  ${AMBER}list${NC}   [file]                list vars (masked)"
    echo -e "  ${AMBER}diff${NC}   <file1> <file2>       diff two env files"
    echo -e "  ${AMBER}validate${NC} [file]              validate syntax"
    echo ""
    echo -e "  ${BOLD}vars${NC}"
    echo -e "  ${AMBER}get${NC}    <file> <key>          get value"
    echo -e "  ${AMBER}set${NC}    <file> <key> <val>    set var"
    echo -e "  ${AMBER}unset${NC}  <file> <key>          remove var"
    echo -e "  ${AMBER}export${NC} [file]                export to shell"
    echo ""
}

# Main dispatch
init_db

case "${1:-help}" in
    push|encrypt)        cmd_vault_push "${@:2}" ;;
    pull|decrypt)        cmd_vault_pull "${@:2}" ;;
    vdiff|vault-diff)    cmd_vault_diff "${@:2}" ;;
    vlist|vault-list)    cmd_vault_list ;;
    audit)               cmd_audit "${@:2}" ;;
    init)                cmd_init "${@:2}" ;;
    list|ls)             cmd_list "${@:2}" ;;
    edit)
        file="${2:-.env}"
        ${EDITOR:-vim} "$file"
        ;;
    get)                 cmd_get "${@:2}" ;;
    set)                 cmd_set "${@:2}" ;;
    unset|rm)            cmd_unset "${@:2}" ;;
    copy|cp)             cmd_copy "${@:2}" ;;
    diff)                cmd_diff "${@:2}" ;;
    validate|check)      cmd_validate "${@:2}" ;;
    export)              cmd_export "${@:2}" ;;
    help|--help|-h)      cmd_help ;;
    *)
        echo -e "${RED}âœ—${NC} unknown: $1"
        cmd_help
        exit 1
        ;;
esac
